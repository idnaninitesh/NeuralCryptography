from learning_rules import hebbian, anti_hebbian, random_walk
import numpy as np


class TPM:
	'''TPM
	A tree parity machine. Generates a binary digit(tau) for a given random vector(X).
	The machine can be described by the following parameters:
	k - The number of hidden neurons
	n - Then number of input neurons connected to each hidden neuron
	l - Defines the range of each weight ({-L, ..., -2, -1, 0, 1, 2, ..., +L })
	m - Num of machines to be generated( used by attacker in majority, genetic attack )
	W - The weight matrix between input and hidden layers. Dimensions : [M, K, N]
	'''
	def __init__(self, k=3, n=4, l=6, m=1):
		'''
		Arguments:
		k - The number of hidden neurons
		n - Then number of input neurons connected to each hidden neuron
		l - Defines the range of each weight ({-L, ..., -2, -1, 0, 1, 2, ..., +L })	
		m - The number of machines to be generated by the attacker			'''

		self.k = k
		self.n = n
		self.l = l
		self.m = m
		if m == 1:
			self.W = np.random.randint(-l, l + 1, [k, n])
		else:
			self.W = np.ndarray([m,k,n],dtype=int)
			for i in range(m):
				self.W[i] = np.random.randint(-l, l + 1, [k, n])

	def get_output(self, X):
		'''
		Returns a binary digit tau for a given random vecor.
		Arguments:
		X - Input random vector
		'''

		k = self.k
		n = self.n
		W = self.W
		m = self.m
		X = X.reshape([k, n])

		if m == 1:
			if W.ndim == 3:
				W=W[0]
			h = np.sum(X * W, axis=1);
			sigma = np.sign(h) # Compute inner activation sigma Dimension:[K]
			for n,i in enumerate(sigma):
				if i == 0:
					sigma[n] = -1

			tau = np.prod(sigma) # The final output

		else:
			h = np.ndarray([m,k], dtype=int)
			sigma = np.ndarray([m,k], dtype=int)
			tau = np.ndarray([m], dtype=int)

			for j in range(m):
				temp = W[j]
				h[j] = np.sum(X * temp, axis=1);
				sigma[j] = np.sign(h[j]) # Compute inner activation sigma Dimension:[K]
				for n,i in enumerate(sigma[j]):
					if i == 0:
						sigma[j][n] = -1

				tau[j] = np.prod(sigma[j]) # The final output

		self.X = X
		self.h = h
		self.sigma = sigma
		self.tau = tau

		return tau

	def __call__(self, X):
		return self.get_output(X)

	def getM(self):
		return self.m

	def update(self, tau2, update_rule='hebbian', j=-1):
		'''
		Updates the weights according to the specified update rule.

		Arguments:
		tau2 - Output bit from the other machine;

		update_rule - The update rule. 
		Should be one of ['hebbian', 'anti_hebbian', random_walk']

		j -  Index of machine whose weight is to be considered( used by attacker )
		'''

		X = self.X
		sigma = self.sigma
		W = self.W
		l = self.l

		if j == -1:
			tau1 = self.tau
			if (tau1 == tau2):
				if update_rule == 'hebbian':
					hebbian(W, X, sigma, tau1, tau2, l)
				elif update_rule == 'anti_hebbian':
					anti_hebbian(W, X, sigma, tau1, tau2, l)
				elif update_rule == 'random_walk':
					random_walk(W, X, sigma, tau1, tau2, l)
				else:
					raise Exception("Invalid update rule. Valid update rules are: " + 
						"\'hebbian\', \'anti_hebbian\' and \'random_walk\'.")
		else:
			tau1 = self.tau[j]
			if (tau1 == tau2):
				if update_rule == 'hebbian':
					hebbian(W[j], X, sigma[j], tau1, tau2, l)
				elif update_rule == 'anti_hebbian':
					anti_hebbian(W[j], X, sigma[j], tau1, tau2, l)
				elif update_rule == 'random_walk':
					random_walk(W[j], X, sigma[j], tau1, tau2, l)
				else:
					raise Exception("Invalid update rule. Valid update rules are: " + 
						"\'hebbian\', \'anti_hebbian\' and \'random_walk\'.")



	def perform_attack(self, num_steps, M, tau1, tau2, update_rule = 'hebbian', attack='simple', avg_steps=0):
		'''
		Performs the attack according to the specifiied attack

		Arguments:
		num_steps = No of steps performed upto the current time step

		tau1 - Output bit of one machine
		tau2 - Output bit of other machine

		update_rule - The update rule. 
		Should be one of ['hebbian', 'anti_hebbian', random_walk']
		
		attack - Attack to be performed
		Should be one of ['simple', 'geometric', 'majority', 'genetic']
		'''
		
		flag = 0;
		
		if attack == 'simple':
			# simple brute force update

			if tau1 == tau2 == self.tau:			
				self.update(tau2, update_rule)
				flag = 1
		elif attack == 'geometric':
			# simple brute force update
			if tau1 == tau2 == self.tau:
				self.update(tau2, update_rule)

			# negate the unit with minimum local field and update
			elif tau1 == tau2 != self.tau:
				min_index = np.argmin(np.absolute(np.array(self.h)))
				#print("Before:" + str(self.h))
				self.h[min_index] = self.h[min_index]*-1
				#print("After:" + str(self.h))
				self.tau = tau2
				self.update(tau2, update_rule)
			flag = 1
		elif attack == 'majority':
			m = self.m
			if m == 1:
				if tau1 == tau2 == self.tau:
					self.update(tau2, update_rule)
					flag = 1
			else:
				if tau1 == tau2:
					# simple brute force update for all the m machines
					for j in range(m):
						if tau2 == self.tau[j]:
							self.update(tau2, update_rule, j)
				flag = 1
		elif attack == 'genetic':
			k = self.k
			n = self.n
			m = self.m
			if tau1 == 1:
				sigmaCheck = [[1, -1, -1],[-1, 1, -1],[-1, -1, 1],[1, 1, 1]]
			else:
				sigmaCheck = [[1, 1, -1],[-1, 1, 1],[-1, 1, 1],[-1, -1, -1]]
		
			if tau1 == tau2:

				flag = 1
				if m <= int(M/4):
					if m == 1:
						 tempW = np.ndarray([4,k,n],dtype=int)
						 tempTau = np.ndarray([4], dtype=int)
						 WTemp = self.W
						 if WTemp.ndim == 3:
						 	WTemp = WTemp[0]
						 for j in range(4):
						 	tempW[j] = WTemp
						 	tempTau[j] = tau1
						 self.m = 4
						 self.sigma = sigmaCheck
						 self.W = tempW
						 self.tau = tempTau
						 for j in range(4):
						 	self.update(tau2, update_rule, j)
					else:
						selfM = self.m
						selfW = self.W
						tempM = selfM * 4
						tempW = np.ndarray([tempM,k,n],dtype=int)
						tempTau = np.ndarray([tempM],dtype=int)
						tempSigma = np.ndarray([tempM, k],dtype=int)
						for j in range(selfM):
							tempW[j*4] = selfW[j]
							tempW[j*4 + 1] = selfW[j]
							tempW[j*4 + 2] = selfW[j]
							tempW[j*4 + 3] = selfW[j]
							tempSigma[j*4] = sigmaCheck[0]
							tempSigma[j*4 +1] = sigmaCheck[1]
							tempSigma[j*4 +2] = sigmaCheck[2]
							tempSigma[j*4 +3] = sigmaCheck[3]
							tempTau[j*4] = tau1
							tempTau[j*4 + 1] = tau1
							tempTau[j*4 + 2] = tau1
							tempTau[j*4 + 3] = tau1

						self.m = tempM
						self.W = tempW
						self.sigma = tempSigma
						self.tau = tempTau
						for j in range(m):
							self.update(tau2, update_rule, j)
				
				else:
					finalM = 0
					selfM = self.m
					selfW = self.W
					selfSigma = self.sigma
					selfTau = self.tau
					finalW = np.ndarray([M,k,n],dtype=int)
					finalTau = np.ndarray([M],dtype=int)
					finalSigma = np.ndarray([M, k],dtype=int)
					#print("Pre Final M : " + str(selfM))
					for j in range(selfM):
						if selfTau[j] == tau2:
							finalW[finalM]=selfW[j]
							finalSigma[finalM]=selfSigma[j]
							finalTau[finalM]=selfTau[j]
							finalM = finalM + 1
					#print("Final Final M : " + str(finalM))
					if finalM == 0:
						for j in np.random.randint(selfM, size=20):
							finalW[finalM]=selfW[j]
							finalSigma[finalM]=selfSigma[j]
							finalTau[finalM]=selfTau[j]
							finalM = finalM + 1
					

					self.m = finalM
					self.W = finalW
					self.sigma = finalSigma
					self.tau = finalTau
					for j in range(finalM):
						self.update(tau2, update_rule, j)

		elif attack == 'majority-flipping':
			m = self.m
			if m == 1:
				if tau1 == tau2 == self.tau:
					self.update(tau2, update_rule)
					flag = 1
			else:
				# use flipping attack for 1/3rd of the time
				if num_steps <= avg_steps:
					if tau1 == tau2:
						for j in range(m):
							if tau2 == self.tau[j]:
								self.update(tau2, update_rule, j)
							else:
								min_index = np.argmin(np.absolute(np.array(self.h[j])))
								self.h[j][min_index] = self.h[j][min_index]*-1
								self.tau[j] = tau2
								self.update(tau2, update_rule, j)
						flag = 1
				else:
				# after 100 steps
				# use flipping attack for odd steps
					if num_steps%2 == 1:
						if tau1 == tau2:
							for j in range(m):
								if tau2 == self.tau[j]:
									self.update(tau2, update_rule, j)
								else:
									min_index = np.argmin(np.absolute(np.array(self.h[j])))
									self.h[j][min_index] = self.h[j][min_index]*-1
									self.tau[j] = tau2
									self.update(tau2, update_rule, j)
							flag = 1
				# use majority flipping procedure for even steps	
					else:
						if tau1 == tau2:
							count = [0, 0, 0, 0]
							
							for j in range(m):
								# for machine disagreeing with Alice or Bob flip the hidden unit as per geometric rule
								# find the most common internal representation and set all the hidden units to that representation
								if tau2 != self.tau[j]:
									# flip as per geometric rule
									min_index = np.argmin(np.absolute(np.array(self.h[j])))
									self.h[j][min_index] = self.h[j][min_index]*-1
									self.sigma[j][min_index] = self.sigma[j][min_index]*-1
									self.tau[j] = tau2

								# find the most commo n internal representation
								
								if tau2 == 1:
									if list(self.sigma[j]) == [1, -1, -1]:
										count[0] += 1
									elif list(self.sigma[j]) == [-1, 1, -1]:
										count[1] += 1
									elif list(self.sigma[j]) == [-1, -1, 1]:
										count[2] += 1
									else:
										count[3] += 1
								else:
									if list(self.sigma[j]) == [-1, 1, 1]:
										count[0] += 1
									elif list(self.sigma[j]) == [1, -1, 1]:
										count[1] += 1
									elif list(self.sigma[j]) == [1, 1, -1]:
										count[2] += 1
									else:
										count[3] += 1


							# set all the hidden units to the most common representation
							max_index = np.argmax(count)
							
							for j in range(m):
								if tau2 == 1:
									if max_index == 0:
										self.sigma[j] = [1, -1, -1]
									elif max_index == 1:
										self.sigma[j] = [-1, 1, -1]
									elif max_index == 2:
										self.sigma[j] = [-1, -1, 1]
									else:
										self.sigma[j] = [1, 1, 1]
								else:
									if max_index == 0:
										self.sigma[j] = [-1, 1, 1]
									elif max_index == 1:
										self.sigma[j] = [1, -1, 1]
									elif max_index == 2:
										self.sigma[j] = [1, 1, -1]
									else:
										self.sigma[j] = [-1, -1, -1]
								self.update(tau2, update_rule, j)

							flag = 1
		else:
			raise Exception("Invalid attack. Valid attacks are: " + 
					"\'simple\', \'geometric\', \'majority\' and \'genetic\'.")

		return flag

